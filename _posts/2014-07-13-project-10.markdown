---
layout: default
modal-id: 10
title: Ergodic Imitation with 7-DoF Franka Arm
short-caption: Ergodic Imitation with 7-DoF Franka Arm
date: 2024-12-1
img: ergodic.gif
youtube: https://www.youtube.com/watch?v=q7HbfBILOt4
alt: image-alt
project-date: 2024-12-1
category: Trajectory planning, Feedforward control
github: 
link: Ergodic
description: <h4><strong>Overview</strong></h4><br><p style="text-align:left;">The purpose of this project is to leverage <strong>ergodic imitation</strong> to learn both desirable and undesirable behaviors. To facilitate effective data collection, I first implemented an <strong>impedance control mode</strong> for a 7-DoF collaborative robotic arm (Franka) in collaboration with Courtney. Subsequently, I developed a <strong>haptic-guided teleoperation</strong> system for the Franka robot. This system enables the user to control <strong>Franka 1</strong>, which operates in impedance control mode, and couples its movements to <strong>Franka 2</strong>, such that any motion of Franka 1 is mirrored by Franka 2.</p><p style="text-align:left;">Following this, I employed a <strong>learning-from-demonstration (LfD)</strong> approach to derive robust task definitions from a combination of positive and negative demonstrations. The algorithmic framework for task learning is based on the <strong>ergodic metric</strong>, a measure of the information content in motion. Finally, I demonstrated the efficacy of this learning approach on (.......) using the 7-DoF Franka arm.</p><br><h4><strong>Video Demo</strong></h4><br><iframe width="600" height="450" src="https://www.youtube.com/embed/q7HbfBILOt4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><br><p style="text-align:left;">To achieve the goal of the project I wrote 4 functions.</p><ul><li><h5 style="text-align:left;">NextState</h5></li><ul><li><p style="text-align:left;">Input<span>:</span> The input of the function includes config, speed, timestep, max_speed</p><br><p style="text-align:left;">config<span>:</span> A 12-vector representing the current configuration of the robot (3 variables for the chassis configuration, 5 variables for the arm configuration, and 4 variables for the wheel angles).</p><p style="text-align:left;">speed<span>:</span> A 9-vector of controls indicating the wheel speeds and the arm joint speeds</p><p style="text-align:left;">timestep<span>:</span> A timestep</p><p style="text-align:left;">max_speed<span>:</span> A positive real value indicating the maximum angular speed of the arm joints and the wheels.</p><p style="text-align:left;">For example, if this value is 12.3, the angular speed of the wheels and arm joints is limited to the range [-12.3 radians/s, 12.3 radians/s]. Any speed in the 9-vector of controls that is outside this range will be set to the nearest boundary of the range.</p></li><li><p style="text-align:left;">Output<span>:</span> The return of the function is new_config</p><p style="text-align:left;">new_config<span>:</span> A 12-vector representing the configuration of robot. </p><p style="text-align:left;">The function NextState is based on a simple first-order Euler step, i.e., new arm joint angles = (old arm joint angles) + (joint speeds) * new wheel angles = (old wheel angles) + (wheel speeds) * new chassis configuration is obtained from odometry. </p></li></ul><br><li><h5 style="text-align:left;">TrajectoryGenerator</h5></li><ul><li><p style="text-align:left;">Input<span>:</span> The input of the function includes Tse_initial, Tsc_initial, Tsc_goal, Tce_grasp, Tce_standoff, and k.</p><p style="text-align:left;">Tse_initial<span>:</span> The initial configuration of the end-effector in the reference trajectory </p><p style="text-align:left;">Tsc_initial<span>:</span> The cube's initial configuration </p><p style="text-align:left;">Tsc_goal<span>:</span> The cube's desired final configuration </p><p style="text-align:left;">Tce_grasp<span>:</span> The end-effector's configuration relative to the cube when it is grasping the cube </p><p style="text-align:left;">Tce_standoff<span>:</span> The end-effector's standoff configuration above the cube, before and after grasping, relative to the cube </p><p style="text-align:left;">k<span>:</span> The number of trajectory reference configurations per 0.01 seconds </p><p style="text-align:left;">Output<span>:</span> The Return of the function is N_final </p><p style="text-align:left;">A representation of the N configurations of the end-effector along the entire concatenated eight-segment reference trajectory. Each of these N reference points represents a transformation matrix T_se of the end-effector frame e relative to s at an instant in time, plus the gripper state (0 or 1). </p></li></ul><br><li><h5 style="text-align:left;">FeedbackControl</h5></li><ul><li><p style="text-align:left;">Input<span>:</span> The input of the function includes X, Xd, Xd_next, Kp, Ki, delta_t </p><p style="text-align:left;">X<span>:</span> The current actual end-effector configuration (also written T_se). </p><p style="text-align:left;">Xd<span>:</span> The current end-effector reference configuration (i.e., T_se,d). </p><p style="text-align:left;">Xd_next<span>:</span> The end-effector reference configuration at the next timestep in the reference trajectory, (i.e., T_se,d,next, at a time Delta t later. </p><p style="text-align:left;">Ki, Kp<span>:</span> the PI gain matrices K_p and K_i. </p><p style="text-align:left;">delta_t<span>:</span> The timestep Delta t between reference trajectory configurations. </p><p style="text-align:left;">Output<span>:</span> </p><p style="text-align:left;">V<span>:</span> the commanded end-effector twist expressed in the end-effector frame </p><p style="text-align:left;">Xerr<span>:</span> the error twist. </p></li></ul><br><li><h5 style="text-align:left;">testJointLimits</h5> <ul><p style="text-align:left;">The function is used to help the robot arm avoid singularities. I choose both joint 3 and joint 4 to be always less than -0.3. </p><p style="text-align:left;">Input<span>:</span> The input of the function includes joint_theta</p><p style="text-align:left;">joint_theta<span>:</span> the theta needed to be check whether reach the limits </p> <p style="text-align:left;">Output<span>:</span></p><p style="text-align:left;">res<span>:</span> which joint reaches the limits </p></li></ul></ul>
---